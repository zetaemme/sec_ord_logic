\documentclass{beamer}

\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{cancel}
\usepackage{stmaryrd}
\usepackage{xcolor}

\definecolor{title_blue}{RGB}{51, 51, 178}

\usetheme{Boadilla}

\title{Second-Order Logic}
\subtitle{Final seminar for "Logic in Computer Science"}
\author{Mattia Zorzan}
\institute{University of Verona}
\date{Last rev. \today}

\begin{document}
    \begin{frame}
        \titlepage
    \end{frame}

    \begin{frame}
        \frametitle{Outline}
        \tableofcontents
    \end{frame}

    \section{Introduction}
        \begin{frame}
            \frametitle{Introduction}
            \begin{itemize}
                \item First-order logic allows "iteration" over the \textit{elements} of a structure
                \item Happens thanks to \textbf{quantifiers}: $ \forall $, $ \exists $
                    \begin{itemize}
                        \item $ \forall x. \phi(x) \rightarrow $ "For each $ x $, $ x $ satisfies the formula $ \phi $"
                        \item $ \exists x. \phi(x) \rightarrow $ "There exists $ x $ s.t. the formula $ \phi $ is satisfied"
                    \end{itemize}
                \item Limiting since we may only need to range over \textit{subsets} or "\textit{combinations}" (e.g. \textit{Cartesian product})
            \end{itemize}
        \end{frame}

        \subsection{A recall on first-order logic}
            \begin{frame}
                \frametitle{A brief recall}
                \begin{itemize}
                    \item Second-order logic "extends" first-order logic
                    \item Since that, let's recall the basics of first-order logic
                    \item Two key parts:
                        \begin{itemize}
                            \item \textit{Syntax}: Which sequences constitute \textbf{well-formed} expressions
                            \item \textit{Semantics}: The \textbf{meaning} behind this expressions
                        \end{itemize}
                \end{itemize}
            \end{frame}

            \subsubsection{Syntax}
                \begin{frame}
                    \begin{center}
                        \begin{Huge}
                            \textcolor{title_blue}{Syntax}
                        \end{Huge}
                    \end{center}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Introduction}
                    \begin{itemize}
                        \item Two base types:
                            \begin{itemize}
                                \item \textbf{Terms}: Represents \textit{objects}
                                \item \textbf{Formulas}: Represents \textit{predicates}
                            \end{itemize}
                        \item Both formed by \textit{symbol} concatenation
                        \item All symbols together form the \textbf{alphabet} of the language
                        \item Can divide symbols in two categories
                            \begin{itemize}
                                \item \textit{Logical} symbols
                                \item \textit{Non-logical} symbols
                            \end{itemize}
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Logical symbols}
                    \begin{itemize}
                        \item \underline{Infinite} set of \textbf{variables}: $ x, y, z, \dots, x_0, x_1, \dots $ (Lowercase letters)
                        \item \textbf{Connectives}: $ \wedge, \vee, \Rightarrow, \neg $
                        \item \textbf{Quantifiers}: $ \forall, \exists $
                        \item \textbf{Equality} (or \textit{Identity}): $ = $
                        \item \textbf{Auxiliary symbols}: (; ); . (\texttt{dot}); , (\texttt{comma})
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Non-logical symbols}
                    \begin{itemize}
                        \item Represents \textit{predicates} (or \textit{relations}), \textit{functions} and \textit{constants}
                        \item $ \forall n \in \mathbb{Z^*} $ we have a set of \textit{n-ary} \textbf{predicate symbols}
                        \[
                            P^n_0, P^n_1, \dots \quad\quad \text{(Uppercase letters)}
                        \] 
                        \item $ \forall n \in \mathbb{Z^*} $ there exist \underline{infinite} \textit{n-ary} \textbf{function symbols}
                        \[
                            f^n_0, f^n_1, \dots \quad\quad \text{(Lowercase letters)}
                        \]
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Formation rules (1)}
                    \begin{definition}[Terms formation]
                        The set \texttt{TERM} of \textit{terms} can be inductively defined by the following rules:
                        \begin{enumerate}
                            \item If $ x $ is a variable, then $ x \in \texttt{TERM}$
                            \item Any expression $ f(t_1, \dots, t_n) $, with $ t_1, \dots, t_n \in \texttt{TERM} $, is a term.\\
                            Since that, the following statement holds
                            \[
                                f(t_1, \dots, t_n) \in \texttt{TERM}
                            \]
                        \end{enumerate}
                    \end{definition}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Formation rules (2)}
                    \begin{definition}[Formulas formation]
                        The set \texttt{FORM} of \textit{formulas} can be inductively defined by the following rules:
                        \begin{enumerate}
                            \item If $ P \in \texttt{PRED}\footnote{The set of \textit{predicate symbols}} $ and $ t_1, \dots, t_n \in \texttt{TERM} $, than $ P(t_1, \dots, t_n) \in \texttt{FORM} $
                            \item If $ t_1, t_2 \in \texttt{TERM} $, than $ t_1 = t_2 \in \texttt{FORM} $
                            \item If $ \phi \in \texttt{FORM} $, than $ \neg \phi \in \texttt{FORM} $
                            \item If $ \phi, \psi \in \texttt{FORM} $, than $ \phi\; \square\; \psi \in \texttt{FORM} $ (with $ \square \in \{ \wedge, \vee, \Rightarrow \} $)
                            \item If $ \phi \in \texttt{FORM} $ and $ x $ is a variable, than $ Qx.\phi \in \texttt{FORM} $ (with $ Q \in \{ \forall, \exists \} $)
                        \end{enumerate}
                    \end{definition}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Variables (1)}
                    \begin{definition}[Free and Bound variables]
                        The \textit{free} and \textit{bound} variable occurrences in a formula are defined inductively by the following rules:
                        \begin{enumerate}
                            \item If $ \phi $ is \textit{atomic}, than any variable $ x \in Var(\phi) $ is \textit{free}
                            \item $ x $ is \textit{free/bound} in $ \neg \phi $ iff $ x $ is \textit{free/bound} in $ \phi $
                            \item $ x $ is \textit{free/bound} in $ \phi\; \square\; \psi $ iff $ x $ is \textit{free/bound} in either $ \phi $ or $ \psi $ (with $ \square \in \{ \wedge, \vee, \Rightarrow \} $)
                            \item $ x $ is \textit{free} in $ Qy.\phi $ iff $ x $ is \textit{free} in $ \phi $ and $ y \neq x $
                            \item $ x $ is \textit{bound} in $ Qy.\phi $ iff $ x $ is \textit{bound} in $ \phi $
                        \end{enumerate}
                    \end{definition}
                \end{frame}

                \begin{frame}
                    \frametitle{Syntax - Variables (2)}
                    \begin{itemize}
                        \item More easily, a variable $ x $ is \textit{bounded} if it occurs in a quantification, $ x $ is \textit{free} otherwise
                        \item A variable can be both \textit{free} and \textit{bounded} in the same formula, e.g.
                        \[
                            P(x, y) \Rightarrow \exists x.Q(x)    
                        \]
                        \begin{enumerate}
                            \item In the \textbf{LHS} $ x $ is \textit{free}
                            \item In the \textbf{RHS} $ x $ is \textit{bounded}
                            \item Even so, the formula is still \textit{well-formed}
                        \end{enumerate}
                        \item A formula with no \textit{free} variables is called a \textbf{sentence}
                    \end{itemize}
                \end{frame}

            \subsubsection{Semantic}
                \begin{frame}
                    \begin{center}
                        \begin{Huge}
                            \textcolor{title_blue}{Semantic}
                        \end{Huge}
                    \end{center}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Structure and Interpretation}
                    \begin{definition}[Structure]
                        A \textit{structure} is formed by a \textit{domain} $ D $, $\mathbb{P} = \{ P_1, \dots, P_n \} $ predicates on $ D $, $ \mathbb{F} = \{ f_1, \dots, f_n \} $ \textbf{total} functions on $ D $ and a set $ \mathbb{C} \subseteq D $ of constants
                    \end{definition}
                    \begin{definition}[Interpretation]
                        Given a \textit{structure} $ \mathfrak{D} $ and a \textit{map} $ (\cdot)^{\mathfrak{D}} $ s.t.
                        \begin{itemize}
                            \item for all $ c $ in my language, $ (c)^\mathfrak{D} = c^\mathfrak{D} \in \mathbb{C} $
                            \item for all \textit{k-ary} function $ f $ in my language, $ (f)^\mathfrak{D} = f^\mathfrak{D}: D^k \to D \in \mathbb{F} $
                            \item for all \textit{n-ary} predicate $ P $ in my language, $ (P)^\mathfrak{D} = P^\mathfrak{D} \subseteq D^k \in \mathbb{P} $
                        \end{itemize}
                        we call $ \langle \mathfrak{D}, (\cdot)^{\mathfrak{D}} \rangle $ an \textit{interpretation}.
                    \end{definition}

                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Evaluation (1)}
                    \begin{itemize}
                        \item Given an \textit{interpretation} and an \textbf{assignment} $ \overline{a} $, it is possible to evaluate a formula
                        \item The \textbf{evaluation} process \textit{maps} the whole formula to a \textbf{truth value}
                        \item The \textit{assignment} $ \overline{a} $ associates each \textit{free variable} with a \textit{truth value}
                        \item If the formula is a \textit{sentence}, $ \overline{a} $ does not affect the \textit{truth value} of the formula
                        \item Next slides shows the evaluation steps   
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Evaluation (2)}
                    \begin{enumerate}
                        \item Extend $ \overline{a} $ to all terms of the language with the following rules:
                            \begin{itemize}
                                \item Each variable $ x $ evaluates to $ \overline{a}(x) $
                                \item Given $ \{ t_1, \dots, t_n \} \in \texttt{TERM} $ evaluated to $ \{ d_1, \dots, d_n \} $, a function $ f(t_1, \dots, t_n) $ evaluates to $ (f)^{\mathfrak{D}}\footnote{Supposing we're evaluating $ f $ in a structure $ \mathfrak{D} $}(d_1, \dots, d_n) $ 
                            \end{itemize}
                        \item Assign each formula to a \textit{truth value} with the following (inductive) rules:
                            \begin{itemize}
                                \item (\textit{Continues in next slides})
                            \end{itemize} 
                    \end{enumerate}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Evaluation (3)}
                    \begin{itemize}
                        \item An \textit{atomic formula} $ P(t_1, \dots, t_n) $ is associated with a \textit{truth value}, depending on the truth of the following:
                            \[
                                \langle v_1, \dots, v_n \rangle \in (P)^{\mathfrak{D}}   
                            \]
                            where $ v_1, \dots, v_n $ represents the evaluation of the predicate terms
                        \item An \textit{atomic formula} $ t_1 = t_2 $ evaluates to a \textit{truth value} depending if $ v_1 = v_2 $ in $ D $, where $ v_1, v_2 $ represents the evaluation of the terms
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Evaluation (4)}
                    \begin{itemize}
                        \item A formula containing \textit{logical connectives} (e.g. $ \phi\; \square\; \psi\footnote{with $ \square \in \{ \wedge, \vee, \Rightarrow \} $}, \neg \phi $) is evaluated according to the \textit{truth table} of the connective
                        \item A formula $ \exists x.\phi $ is evaluated \texttt{true} iff exists an assignment $ \overline{a}' $ s.t. it differs from $ \overline{a} $ only for the assignment of $ x $ and $ \phi $ is evaluated \texttt{true} via the $ \overline{a}' $ assignment, \texttt{false} otherwise
                        \item A formula $ \forall x. \phi $ is evaluated \texttt{true} iff exists an assignment $ \overline{a}' $ s.t. it differs from $ \overline{a} $ only for the assignment of $ x $ and $ \phi $ is evaluated \texttt{true} for all values in $ \overline{a}' $, \texttt{false} otherwise
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Evaluation (5)}
                    \begin{itemize}
                        \item Given a \textit{structure} $ \mathfrak{D} $, evaluation can be seen as a \textit{map}
                        \[
                            \rho_\mathfrak{D}: Var \to D
                        \]
                        \item We can use the $ \llbracket \cdot \rrbracket $ notation to express the evaluation of a \textit{term}
                        \begin{definition}
                            Given a structure $ \mathfrak{D} $ and $ \llbracket \cdot \rrbracket_{\rho_\mathfrak{D}}: \texttt{TERM} \to D $, we can define
                            \begin{enumerate}
                                \item $ \llbracket c \rrbracket_{\rho_\mathfrak{D}} = c^\mathfrak{D}$
                                \item $ \llbracket x \rrbracket_{\rho_\mathfrak{D}} = \rho_\mathfrak{D}(x) $
                                \item $ \llbracket f(t_1, \dots, t_n) \rrbracket_{\rho_\mathfrak{D}} = f^\mathfrak{D}(\llbracket t_1 \rrbracket_\mathfrak{D}, \dots, \llbracket t_n \rrbracket_\mathfrak{D}) $
                            \end{enumerate}
                        \end{definition}
                    \end{itemize}
                \end{frame}

                \begin{frame}
                    \frametitle{Semantic - Satisfiability}
                    \begin{definition}[Satisfiability relation]
                        Given a \textit{structure} $ \mathfrak{D} $ we can recursively define the \textit{satisfiability relation} $ \vDash $ as:
                        \begin{enumerate}
                            \item $ \rho_\mathfrak{D}\; \cancel{\vDash}\; \bot $
                            \item $ \rho_\mathfrak{D} \vDash P(t_1, \dots, t_n) \Leftrightarrow \langle \llbracket t_1 \rrbracket_{\rho_\mathfrak{D}}, \dots, \llbracket t_n \rrbracket_{\rho_\mathfrak{D}} \rangle \in \mathbb{R} $
                            \item $ \rho_\mathfrak{D} \vDash t_1 = t_2 \Leftrightarrow\llbracket t_1 \rrbracket_{\rho_\mathfrak{D}} = \llbracket t_2 \rrbracket_{\rho_\mathfrak{D}} $
                            \item $ \rho_\mathfrak{D} \vDash (\phi \Rightarrow \psi) \Leftrightarrow \rho_\mathfrak{D}\; \cancel{\vDash}\; \phi \text{ o } \rho_\mathfrak{D} \vDash \psi $
                            \item $ \rho_\mathfrak{D} \vDash (\phi \wedge \psi) \Leftrightarrow \rho_\mathfrak{D} \vDash \phi \text{ e } \rho_\mathfrak{D} \vDash \psi $
                            \item $ \rho_\mathfrak{D} \vDash (\phi \vee \psi) \Leftrightarrow \rho_\mathfrak{D} \vDash \phi \text{ o } \rho_\mathfrak{D} \vDash \psi $
                            \item $ \rho_\mathfrak{D} \vDash \forall x.\, \phi(x) \Leftrightarrow \forall a \in D: \rho_\mathfrak{D}[x/a] \vDash \phi $
                            \item $ \rho_\mathfrak{D} \vDash \exists x.\, \phi(x) \Leftrightarrow \exists a \in D: \rho_\mathfrak{D}[x/a] \vDash \phi $
                        \end{enumerate}
                    \end{definition}
                \end{frame}

        \section{Second-Order Logic}
            \begin{frame}
                \begin{center}
                    \begin{Huge}
                        \textcolor{title_blue}{Second-Order Logic}
                    \end{Huge}
                \end{center}
            \end{frame}

            \begin{frame}
                \frametitle{Syntax and Semantic}
                \begin{itemize}
                    \item As said before, second-order logic \textit{extends} first-order logic
                    \item The \textit{terms} and \textit{formulas} are unchanged...
                    \item ...but we need to redefine \textit{structures} to represent this "\textit{extension}"
                \end{itemize}
            \end{frame}

            \begin{frame}
                \frametitle{Structure}
                \begin{definition}[Second-Order Structure]
                    A \textit{structure} is formed by a \textit{domain} $ D $, a set $ D^* = \langle D_n\; \vert\; n \in \mathbb{N} \rangle$ with $ D_n \subseteq \mathcal{P}(A^n) $, a set $ \mathbb{P} = \{ P_1^n, \dots, P_k^n \} $ of \textit{predicates} s.t. $ P_i^n \in D_n $ and a set of \textit{constants} $ \mathbb{C} \subseteq D $
                \end{definition}
                \begin{itemize}
                    \item If $ D_n $ contains \textbf{all} n-ary predicates ($ D_n = \mathcal{P}(D^n) $) we call the structure \textit{full}
                    \item Even if the \textit{elements} of a Second-Order structure are slightly different from the elements of a First-Order structure, we can use the same rules for \textbf{interpretation} and \textbf{evaluation}
                \end{itemize}
            \end{frame}
            
            \begin{frame}{Satisfiability}
                \begin{definition}[Second-Order Satisfiability relation]
                    Given a \textit{Second-Order structure} $ \mathfrak{D} $ and a \textit{language} $ \mathcal{L} $ that defines a name $ \overline{S} $ for all $ S \in D $, we can define the \textit{satisfiability relation} $ \vDash $ as:
                    \begin{enumerate}
                        \item $ \rho_\mathfrak{D}\; \cancel{\vDash}\; \bot $
                        \item $ \rho_\mathfrak{D} \vDash \overline{S}^n(\overline{s}_1, \dots, \overline{s}_n) \Leftrightarrow \langle s_1, \dots, s_n \rangle \in S^n $\footnote{By using this notation, we can handle all types of \textit{predicates} with one rule}
                        \item All connectives follow the same rules of First-Order Logic
                        \item Quantification over a \textit{variable} follow the same rules of First-Order Logic
                        \item $ \rho_\mathfrak{D} \vDash \forall P^n_i. \phi(P^n_i) \Leftrightarrow \forall S^n \in D_n: \rho_\mathfrak{D} \vDash \phi(S^n) $
                        \item $ \rho_\mathfrak{D} \vDash \exists P^n_i. \phi(P^n_i) \Leftrightarrow \exists S^n \in D_n: \rho_\mathfrak{D} \vDash \phi(\overline{S}^n) $
                    \end{enumerate}
                \end{definition}
            \end{frame}
            
            \begin{frame}{Natural Deduction}
                \begin{itemize}
                    \item We need to add a set of \textit{rules} that allows to validly \textbf{derive} the new "extended" \textit{quantifications}
                \end{itemize}
                \begin{columns}[c]
                    \begin{column}{0.5\textwidth}
                        \begin{prooftree}
                			\AxiomC{$ \phi $}
                			\RightLabel{$ \forall^2I $}
                			\UnaryInfC{$ \forall P^n.\phi $}
                		\end{prooftree}
                		\begin{prooftree}
                			\AxiomC{$ \phi^* $}
                			\RightLabel{$ \exists^2I $}
                			\UnaryInfC{$ \exists P^n.\phi $}
                		\end{prooftree}
                    \end{column}
                    \hfill
                    \begin{column}{0.5\textwidth}
                        \begin{prooftree}
                			\AxiomC{$ \forall P^n.\phi $}
                			\RightLabel{$ \forall^2E $}
                			\UnaryInfC{$ \phi^* $}
                		\end{prooftree}
                		\begin{prooftree}
                		    \AxiomC{$ \exists P^n. \phi $}
                		    \AxiomC{$ [\phi] $}
                		    \noLine
                		    \UnaryInfC{$ \vdots $}
                		    \noLine
                		    \UnaryInfC{$ \psi $}
                			\RightLabel{$ \exists^2E $}
                			\BinaryInfC{$ \psi $}
                		\end{prooftree}
                    \end{column}
                \end{columns}
                \vspace{.5cm}
                \begin{itemize}
                    \item $ \phi^* $ is $ \phi[P^n(t_1, \dots, t_n) / \psi(t_1, \dots, t_n)] $, where $ \psi $ is a generic formula
                    \item No $ t_i $ becomes \textit{bounded} during the substitution above, so $ \psi $ cannot \textit{quantify} any term $ t_1, \dots, t_n $
                \end{itemize}
            \end{frame}
\end{document}
